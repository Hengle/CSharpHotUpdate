FCScript热更原理：

FCScript使用了一套自定义的字节码，与lua类似，虚拟机层采用switch指令的方式解释执行字节码，
所以可以在启动前检测并下载并加载最新的字节码文件，达到热更的目的。

伪码如下：
for(; pyCmd < pyEnd; )
{
    byte  nCmdType = pyCmd[0]; 
    switch(nCmdType)
    {
       case 指令1: ... break;
       case 指令2: ... break;
       case 指令3: ... break;
       case 指令N: ... break;
    }
}

// 初始化脚本全局对象
extern "C" void fc_init();

// 设置脚本字节码
extern "C"  void fc_set_code_data(byte[] pFileData, int nFileDataSize, int nProjCode);

与lua不一样的是，FCScript采用自动托管的虚拟机，调用脚本接口时，并不需要上层自己维护虚拟机。
脚本系统在调用fc_init初始化后，通过fc_call调用脚本函数时，系统会自动维护虚拟机实例。
默认情况下，fc_call调用都会使用一个全局的虚拟机来解释执行对应的函数代码，函数执行完成后，
归还这个虚拟器。
如果函数中启动了协程，系统会自动启动一个新的虚拟机来解释执行对应的协程函数。
如果函数中调用了await异步接口，系统就会将当前虚拟机挂起，推出调用函数，并重新创建一个主虚拟机。

所以，大多数情况下，只要没有调用协程，或异步await接口，fc_call总是共用一个全局的虚拟机对象。
这个有利于性能的提升，用户也不需要关心，也不用去释放这个虚拟机。

与ILRuntime的机制一样，FCScript编译器会将所有的脚本编译成一个字节码文件。
不同与Lua, 它不能运行时编译（那样会影响性能），不能单独编译一个文件，因为C#的代码是面向对象的，
不同的源码文件之间存在一定的关联性。所以脚本只能整体编译更新，不能单独更新一个源码文件。

热更新流程是这样的：
1、重新编译脚本工程（每次修改都是重新编译的），生成字节码文件，打包。
2、上传字节码文件到服务器（如CDN服务器）
3、客户端启动后，走通用的版本检测机制，将修改的脚本字节码文件下载到本地。
4、客户端加载字节码文件，调用fc_set_code_data设置给脚本系统。
5、正常调用脚本中的代码，进入游戏。

那么，FCScript字节码文件是什么格式呢？
它是自定义的二进制数据，你可以把它当作文本打包，如果在Unity在要打包，请先修改成 .bytes

需要注意的是：
FCScript字节码文件的内容，不是字符串，不要把它当做文本文件来加载，不然可能导致脚本字节码丢失与错乱。









